# 数据结构与算法

> author：spongehah
> description：我学习算法时的记录
> 参考网站：
> 1、[Hello算法](https://www.hello-algo.com/)
> 2、[代码随想录](https://programmercarl.com/)
> 免责声明：以下记录中的 部分图 和 少部分文字 都出自于这两个网站

```markmap
# 数据结构与算法
## 数据结构
### 1 数组
#### 1.1 二分查找
#### 1.2 移除元素
#### 1.3 最小子数组
#### 1.4 螺旋矩阵
#### 1.5 小总结
### 2 链表
#### 2.1 移除链表元素
#### 2.2 手写单向链表
#### 2.3 手写双向链表
#### 2.4 反转链表
#### 2.5 两两交换相邻节点
#### 2.6 移除链表的倒数第 N 个结点
#### 2.7 相交链表
#### 2.8 环形链表Ⅱ
#### 2.9 小总结
### 3 哈希表
#### 3.1 字母异位词
#### 3.2 两数之和 与 四数相加Ⅱ
#### 3.3 其它
### 4 字符串
#### 4.1 反转字符串
#### 4.2 实现strStr()
#### 4.3 重复的子字符串
## 二分查找
## 双指针法
## 滑动窗口
## KMP前缀表算法
```

[TOC]

# 数据结构

## 1 数组

### 1.1 二分查找

二分查找也是只适用于 数组，具体详情请看下面的**二分查找**

### 1.2 移除元素

体详情请看下面的**双指针法**

### 1.3 最小子数组

体详情请看下面的**滑动窗口**

### 1.4 螺旋矩阵

![img](image/算法.assets/spiral1.jpg)

相关题目：
[59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)
[54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)
[剑指Offer 29.顺时针打印矩阵](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

解法：
1 左闭右开 模拟顺时针遍历
2 普通模拟顺时针遍历

59.螺旋矩阵 II 举例：

```java
//左闭右开 模拟顺时针遍历
class Solution {
    public int[][] generateMatrix(int n) {
        int loop = 0; //循环次数
        int start = 0; //循环开始点(start,start)
        int count = 1; //递增填充数字
        int i,j;
        int [][] res = new int[n][n];

        while(loop++ < n/2) {
            //上侧从左到右
            for(j = start; j < n - loop; j++) res[start][j] = count++;

            //右侧从上到下
            for(i = start; i < n - loop; i++) res[i][j] = count++;

            //下侧从右到左
            for(; j >= loop; j--) res[i][j] = count++;

            //左侧从下到上
            for(; i >= loop; i--) res[i][j] = count++;
            
            start++;
        }

        if (n % 2 == 1) {
            res[start][start] = count;
        }
        return res;
    }
}
```

```java
//普通模拟顺时针遍历
class Solution {
    public int[][] generateMatrix(int n) {
        //定义 左右上下 边界的初始值
        int l = 0, r = n - 1, t = 0, b = n - 1;
        int [][] res = new int[n][n];
        int tar = n * n;
        int num = 1;

        while(num <= tar) {
            //left to right
            for(int i = l; i <= r; i++) res[t][i] = num++;
            t++;

            //top to bottom
            for(int i = t; i <= b; i++) res[i][r] = num++;
            r--;

            //right to left
            for(int i = r; i >= l; i--) res[b][i] = num++;
            b--;

            //bottom to top
            for(int i = b; i >= t; i--) res[i][l] = num++;
            l++;
        }
        return res;
    }
}

//非正方形矩阵时，使用以下循环：
while(true) {
    for(...) ...
	if(num == tar) break;
    
    for(...) ...
	if(num == tar) break;
    ...
}
```

### 1.5 小总结

> 图出自文章顶部声明的参考网站：[代码随想录](https://programmercarl.com/)

![img](image/算法.assets/数组总结.png)

## 2 链表

> 正常的链表，头节点head指向的就是链表中第一个节点，但是当我们想要对头节点进行修改的时候就会不方便，所以我们可以**引入一个虚拟头节点dummyHead，使dummyHead的next节点为链表中第一个节点**

### 2.1 移除链表元素

[203.移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummyHead = new ListNode(0);
        //设置一个虚拟头节点，会方便操作很多
        dummyHead.next = head;
        ListNode temp = dummyHead;
        while (temp.next != null) {
            if (temp.next.val == val) {
                temp.next = temp.next.next;
            } else {
                temp = temp.next;
            }
        }
        return dummyHead.next;
    }
}
```

### 2.2 手写单向链表

[707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

题目要求：

- `MyLinkedList()` 初始化 `MyLinkedList` 对象。
- `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。
- `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
- `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
- `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。

设置一个**虚拟头节点**

```java
class ListNode {
    int val;
    ListNode next;
    public ListNode(){}
    public ListNode(int val) {this.val = val;}
}

class MyLinkedList {
    int size;
    //虚拟头节点，不是真的头节点
    ListNode dummyHead;

    public MyLinkedList() {
        dummyHead = new ListNode(0);//默认值0
        size = 0;
    }
    
    public int get(int index) {
        if(index < 0 || index >= size) {
            return -1;
        }
        ListNode currentNode = dummyHead;
        for(int i = 0; i <= index; i++) {
            currentNode = currentNode.next;
        }
        return currentNode.val;
    }
    
    public void addAtIndex(int index, int val) {
         if(index < 0 || index > size) {
            return;
        }
        size++;
        //要插入位置的前一个节点
        ListNode pre = dummyHead;
        for(int i = 0; i < index; i++) {
            pre = pre.next;
        }
        ListNode node = new ListNode(val);
        node.next = pre.next;
        pre.next = node;
    }
    
    public void addAtHead(int val) {
        ListNode node = new ListNode(val);
        node.next = dummyHead.next;
        dummyHead.next = node;
        size++;
        //也可以使用：this.addAtIndex(0, val);
    }
    
    public void addAtTail(int val) {
       this.addAtIndex(size, val);
    }
    
    public void deleteAtIndex(int index) {
        if(index < 0 || index >= size) {
            return;
        }
        size--;
        ListNode pre = dummyHead;
        for(int i = 0; i < index; i++) {
            pre = pre.next;
        }
        pre.next = pre.next.next;
    }
}
```

### 2.3 手写双向链表

还是题：[707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

设置一个**虚拟头节点**和**虚拟尾节点**，都不算在链表元素里

```java
class ListNode {
    int val;
    ListNode next, prev;
    public ListNode(){}
    public ListNode(int val) {this.val = val;}
}

class MyLinkedList {
    int size;
    //虚拟头节点 和 虚拟尾节点，都不算在链表元素里
    ListNode dummyHead, tail;

    public MyLinkedList() {
        dummyHead = new ListNode(0);//默认值0
        tail = new ListNode(0);
        size = 0;
        dummyHead.next = tail;
        tail.prev = dummyHead;
    }
    
    public int get(int index) {
        if(index < 0 || index >= size) {
            return -1;
        }
        ListNode currentNode = dummyHead;
        //判断从哪边遍历时间更短
        if(index >= size / 2) {
            currentNode = tail;
            for(int i = size; i > index; i--){
                currentNode = currentNode.prev;
            }
        }else {
            for(int i = 0; i <= index; i++) {
                currentNode = currentNode.next;
            }   
        }
        return currentNode.val;
    }
    
    public void addAtHead(int val) {
        ListNode node = new ListNode(val);
        node.next = dummyHead.next;
        dummyHead.next.prev = node;
        node.prev = dummyHead;
        dummyHead.next = node;
        size++;
        //也可以使用：this.addAtIndex(0, val);
    }
    
    public void addAtTail(int val) {
       this.addAtIndex(size, val);
    }
    
    public void addAtIndex(int index, int val) {
         if(index < 0 || index > size) {
            return;
        }
        size++;
        //要插入位置的前一个节点
        ListNode pre = dummyHead;
        for(int i = 0; i < index; i++) {
            pre = pre.next;
        }
        ListNode node = new ListNode(val);
        node.next = pre.next;
        pre.next.prev = node;
        node.prev = pre;
        pre.next = node;
    }
    
    public void deleteAtIndex(int index) {
        if(index < 0 || index >= size) {
            return;
        }
        size--;
        ListNode pre = dummyHead;
        for(int i = 0; i < index; i++) {
            pre = pre.next;
        }
        pre.next.next.prev = pre;
        pre.next = pre.next.next;
    }
}
```

### 2.4 反转链表

[206.反转链表](https://leetcode.cn/problems/reverse-linked-list/)

```java
//双指针法
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur = head, prev = null, temp = null;
        while(cur != null) {
            temp = cur.next;
            cur.next = prev;
            prev = cur;
            cur = temp;
        }
        return prev;//cur == null，返回prev
    }
}
```

```java
//递归法
class Solution {
    public ListNode reverseList(ListNode head) {
        return recur(head, null);    // 调用递归并返回
    }
    private ListNode recur(ListNode pre, ListNode cur) {
        if (cur == null) return pre; // 终止条件
        ListNode res = recur(cur, cur.next);  // 递归后继节点
        cur.next = pre;              // 修改节点引用指向
        return res;                  // 返回反转链表的头节点
    }
}
```

还可以使用栈的方式

### 2.5 两两交换相邻节点

[24.两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

```java
//双指针法
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        ListNode cur = dummyHead.next;
        ListNode pre =  dummyHead, next = null;
        int count = 0;
        while(cur != null) {
          if(cur.next != null) {//可以和while合并条件
            next = cur.next;
            pre.next = next;
            cur.next = next.next;
            next.next = cur;
            pre = cur;
          }
          cur = cur.next;
        }
        return dummyHead.next;
    }
}
```

### 2.6 移除链表的倒数第 N 个结点

[19.删除(移除)链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```java
//双指针法
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        ListNode cur = dummyHead.next;
        ListNode slowIndex = dummyHead, fastIndex = cur;

        while(fastIndex != null && n-- > 0) {
            fastIndex = fastIndex.next;
        }

        // while(cur != null) {
        //     if(fastIndex == null) {
        //         slowIndex.next = cur.next;
        //         break;
        //     }
        //     cur = cur.next;
        //     fastIndex = fastIndex.next;
        //     slowIndex = slowIndex.next;
        // }

        while(fastIndex != null) {
            cur = cur.next;
            fastIndex = fastIndex.next;
            slowIndex = slowIndex.next;
        }
        slowIndex.next = cur.next;
        return dummyHead.next;
    }
}
//还可以使用栈的方式
```

### 2.7 相交链表

[160.相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

![image-20231206225055897](image/算法.assets/image-20231206225055897.png)

思路：让长的链表的指针移动到短的链表的起始指针处对齐，然后同时向后移动两个指针，直到相等或遍历完

```java
//上面的思路
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode A = headA, B = headB;
        while (A != B) {
            A = A != null ? A.next : headB;
            B = B != null ? B.next : headA;
        }
        return A;
    }
}

//使用集合Map，不用List是因为list.contains()时间复杂度为O(n)，而map.containsKey()时间复杂度为O(1)
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA, curB = headB;

        Map<ListNode,String> map = new HashMap<>();
        while(curB != null) {
            map.put(curB,"");
            curB = curB.next;
        }

        while(curA != null) {
            if(map.containsKey(curA)) {
                return curA;
            }
            curA = curA.next;
        }
        return null;
    }
}

//还可以使用栈，先两个链表全部入栈，然后出栈时两个链表尾部正好对齐，直到遇到不相等的节点
```

### 2.8 环形链表Ⅱ

[142.环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

双指针法思路：

1. f=2s （快指针每次2步，路程刚好2倍）
2. f = s + nb (相遇时，刚好多走了n圈）

推出：s = nb

从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。

如何知道slow刚好走了a步？ 从head开始，和slow指针一起走，相遇时刚好就是a步

```java
//双指针法
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head, fast = head;
        while(true) {
            if(fast == null || fast.next == null) return null;
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow) break;
        }
        fast = head;
        while(slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
```

```java
//使用集合Map，不用List是因为list.contains()时间复杂度为O(n)，而map.containsKey()时间复杂度为O(1)
public class Solution {
    public ListNode detectCycle(ListNode head) {
        Map<ListNode,String> map = new HashMap<>();
        ListNode cur = head;
        while(cur != null) {
            if(map.containsKey(cur)) {
                return cur;
            }
            map.put(cur,"");
            cur = cur.next;
        }
        return null;
    }
}
```

### 2.9 小总结

> 图出自文章顶部声明的参考网站：[代码随想录](https://programmercarl.com/)

![img](image/算法.assets/链表总结.png)

## 3 哈希表

### 3.1 字母异位词

[242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)
[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)
[438.找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/) <=> 找到字符串中由另一个字符串的字符所组成的字串 -> 滑动窗口

242.有效的字母异位词 举例：

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        //使用哈希表计数
        Map<Character, Integer> map = new HashMap<>(26);//一共就26个英文字母（小写）
        for(int i = 0; i < s.length(); i++) {
            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);
        }
        for(int i = 0; i < t.length(); i++) {
            map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) - 1);
        }
        for(int val : map.values()) {
            if(val != 0) {
                return false;
            }
        }
        return true;
    }
}
```

438.找到字符串中所有字母异位词 举例在滑动窗口中

### 3.2 两数之和 与 四数相加Ⅱ

[1. 两数之和](https://leetcode.cn/problems/two-sum/)
[454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

还有 三数之和 与 四数之和 不适合用哈希表，适合用**双指针法**，题目链接在双指针法中

```java
//1. 两数之和
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        int[] res = new int[2];

        for(int i = 0; i < nums.length; i++) {
            int temp = target - nums[i];
            if(map.containsKey(temp)) {
                res[0] = i;
                res[1] = map.get(temp);
                break;
            }
            map.put(nums[i], i);
        }
        return res;
    }
}
```

```java
//454. 四数相加 II
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i : nums1) {
            for(int j : nums2) {
                map.put(i + j, map.getOrDefault(i + j, 0) + 1);
            }
        }

        int count = 0;
        for(int i : nums3) {
            for(int j : nums4) {
                count += map.getOrDefault(0 -i - j, 0);
            }
        }
        return count;
    }
}
```

### 3.3 其它

[202. 快乐数](https://leetcode.cn/problems/happy-number/)
[383. 赎金信](https://leetcode.cn/problems/ransom-note/)

## 4 字符串

### 4.1 反转字符串

[344.反转字符串](https://leetcode.cn/problems/reverse-string/)
[541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

使用双指针法

```java
//344.反转字符串
class Solution {
    public void reverseString(char[] s) {
        int left = 0, right = s.length - 1;
        while(left < right) {
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
    }
}
```

```java
//541. 反转字符串 II
class Solution {
    public String reverseStr(String s, int k) {
        int start = 0;
        char[] chars = s.toCharArray();
        int length = chars.length;
        while(start < length) {
            int firstK = (start + k > length ? length : start + k);
            int secondK = (start + (2*k) > length ? length : start + (2*k));
            reverse(chars, start, firstK - 1);
            start += (2*k);
        }

        return new String(chars);
    }

    private void reverse(char[] chars, int left, int right) {
        while(left < right) {
            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;
            left++;
            right--;
        }
    }
}
```

### 4.2 反转字符串中的单词

[151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

```java
//shu
class Solution {
    public String reverseWords(String s) {
        s = s.trim();
        StringBuilder sb = new StringBuilder();

        int right = s.length();
        int left = 0;
        for(int i = s.length() - 1; i >= 0; i--) {
            if(s.charAt(i) == ' ') {
                left = i + 1;
                sb.append(s.substring(left, right) + " ");
                while(i >= 0 && s.charAt(i - 1) == ' ') {
                    i--;
                }
                right = i;
            }else if(i == 0) {
                left = i;
                sb.append(s.substring(left, right));
            }
        }
        return sb.toString();
    }
}
```

[151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

### 4.3 实现strStr()

[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)	即实现strStr()

解答在 《KMP前缀表算法》中，可以用KMP、滑动窗口、用java的substring()三种方法

### 4.4 重复的子字符串

[459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

也是使用KMP算法，解答在 《KMP前缀表算法》中

## 5 栈和队列

### 5.1 栈

[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

```java
class Solution {

    Stack<Character> stack = new Stack<>();

    public boolean isValid(String s) {
        char[] chars = s.toCharArray();
        
        for(char ch : chars) {
            if(!stack.isEmpty()) {
                if(verify(ch)) {
                    stack.pop();
                    continue;
                }
            }
            stack.push(ch);
        }
        return stack.isEmpty();
    }

    private boolean verify(char ch) {
        char peek = stack.peek();
        return (peek == '{' && ch == '}') || (peek == '(' && ch == ')') || (peek == '[' && ch == ']');
    }
}
```

[1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)	区别去重，去重是移除相等的值，这个是动态去除相邻重复项

```java
class Solution {
    public String removeDuplicates(String s) {
        // Stack<Charater> stack = new Stack<>();
        //模拟栈
        StringBuilder stackSB = new StringBuilder();
        for(int i = 0; i < s.length(); i++) {
            if(stackSB.length() > 0 && s.charAt(i) == stackSB.charAt(stackSB.length() - 1)) {
                stackSB.deleteCharAt(stackSB.length() - 1);
                continue;
            }
            stackSB.append(s.charAt(i));
        }
        return stackSB.toString();
    }
}
```

[150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack = new LinkedList();
        for (String s : tokens) {
            if ("+".equals(s)) {        // leetcode 内置jdk的问题，不能使用==判断字符串是否相等
                stack.push(stack.pop() + stack.pop());      // 注意 - 和/ 需要特殊处理
            } else if ("-".equals(s)) {
                stack.push(-stack.pop() + stack.pop());
            } else if ("*".equals(s)) {
                stack.push(stack.pop() * stack.pop());
            } else if ("/".equals(s)) {
                int temp1 = stack.pop();
                int temp2 = stack.pop();
                stack.push(temp2 / temp1);
            } else {
                stack.push(Integer.valueOf(s));
            }
        }
        return stack.pop();
    }
}
```

### 5.2 队列

[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> deque = new ArrayDeque<>();
        int len = nums.length;
        int[] res = new int[len - k + 1];
        int index = 0;//数组下标

        for(int i = 0; i < len; i++) {
            //如果对应的下标不在滑动窗口内，就移除
            while(!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }

            //保证队列里的元素按照从队头到队尾是从大到小排列的，若不是从大到小排列，则移除非递减的部分，然后插入元素
            while(!deque.isEmpty() && nums[i] > nums[deque.peekLast()]) {
                deque.pollLast();
            }

            deque.offerLast(i);

            //从第一个窗口右侧开始放入元素
            if(i >= k - 1) {
                res[index++] = nums[deque.peekFirst()];
            }
        }
        return res;
    }
}
```

[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

```java
//代码随想录答案
public int[] topKFrequent1(int[] nums, int k) {
        Map<Integer,Integer> map = new HashMap<>();//key为数组元素值,val为对应出现次数
        for(int num:nums){
            map.put(num,map.getOrDefault(num,0)+1);
        }
        //在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数
        //出现次数按从队头到队尾的顺序是从大到小排,出现次数最多的在队头(相当于大顶堆)
        PriorityQueue<int[]> pq = new PriorityQueue<>((pair1, pair2)->pair2[1]-pair1[1]);
        for(Map.Entry<Integer,Integer> entry:map.entrySet()){//大顶堆需要对所有元素进行排序
            pq.add(new int[]{entry.getKey(),entry.getValue()});
        }
        int[] ans = new int[k];
        for(int i=0;i<k;i++){//依次从队头弹出k个,就是出现频率前k高的元素
            ans[i] = pq.poll()[0];
        }
        return ans;
    }
}

//我做的，因为是队列题，所以推荐
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    for(int num : nums) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    //模拟大顶堆，这里我们可以用PriorityQueue
    List<Map.Entry<Integer, Integer>> list = new ArrayList<>();
    list.addAll(map.entrySet());
    list.sort((entry1, entry2) -> entry2.getValue() - entry1.getValue());
    list = list.subList(0, k);
    int[] res = new int[k];
    int index = 0;
    for (Map.Entry<Integer, Integer> entry : list) {
        res[index++] = entry.getKey();
    }
    return res;
}
```



# 二分查找

适用数据结构：数组
**适用条件：**数组有序，元素不重复，若重复返回的将是其中一个重复元素的下标

> 重点：若数组**不包含 target** 时，最终 left 和 right 会分别指向首个大于、小于 target 的元素。

两种实现方法：

1. 左闭右闭
2. 左闭右开

二分法：一般是**查找点位**（边界、插入点、平方根）

相关问题：

- [二分查找插入点](https://www.hello-algo.com/chapter_searching/binary_search_insertion/)
  - 不包含重复值 题目：[35.搜索插入位置](https://programmercarl.com/0035.搜索插入位置.html)
  - 包含重复值
- [二分查找边界](https://www.hello-algo.com/chapter_searching/binary_search_edge/)

相关题目：
[704. 二分查找](https://leetcode.cn/problems/binary-search/)
[35.搜索插入位置](https://programmercarl.com/0035.搜索插入位置.html)
[34.在排序数组中查找元素的第一个和最后一个位置](https://programmercarl.com/0034.在排序数组中查找元素的第一个和最后一个位置.html)	左右边界
[69.x 的平方根](https://leetcode.cn/problems/sqrtx/)	转换为查找右边界
[367.有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)	普通的二分查找



34.在排序数组中查找元素的第一个和最后一个位置 举例：

**查找左边界：**

> 查找左边界也是 二分查找插入点 包含重复值 的解法

1. 方法一：查找到 nums[middle] == target后，线性相左递归到不等于target

2. 方法二：查找到 nums[middle] == target后，使right继续等于middle - 1

   ```java
   private int getLeftBorder(int[] nums, int target) {
       int left = 0;
       int right = nums.length - 1;
       while (left <= right) {
           int middle = left + (right - left) / 2;
           if(nums[middle] < target) {
               left = middle + 1;
           } else if(nums[middle] > target) {
               right = middle - 1;
           } else {
               right = middle - 1; //right继续等于middle - 1
           }
       }
       return left;//不包含target时right是第一个小于，那这里left就是第一个大于等于
   }
   ```

   > 做题重点是上面我们强调的：若数组**不包含 target** 时，最终 left 和 right 会分别指向首个大于、小于 target 的元素。
   > 我们的关键是找到了nums[middle] == target，继续更改right的值，直到不满足条件left <= right，所以**情况类似不包含 target**，所以满足结论最终 left 和 right 会分别指向首个大于、小于 target 的元素。

   特殊情况判定：

   ```java
   //  ①target在整个nums数组两边           ②不存在nums数组中
   if(leftBorder == nums.length || nums[leftBorder] != target) {
       return new int[]{-1,-1};
   }
   if (rightBorder == -1 || nums[rightBorder] != target) {
       return new int[]{-1,-1};
   }
   ```

**查找右边界：**

1. 方法一：复用查找左边界，即查找比target大1的值 的最左边那个序号再减1(其实就是right)

   ```java
   int rightBorder = getLeftBorder(nums, target + 1) - 1;
   ```

2. 方法二：仿照查找左边界方法二：

   ```java
   private int getRightBorder(int[] nums, int target) {
       int left = 0;
       int right = nums.length - 1;
       while (left <= right) {
           int middle = left + (right - left) / 2;
           if(nums[middle] < target) {
               left = middle + 1;
           } else if(nums[middle] > target) {
               right = middle - 1;
           } else {
               left = middle + 1; //left继续等于middle + 1
           }
       }
       return right;//不包含target时left是第一个大于，那这里right就是第一个小于等于
   }
   ```



**整体解法三：**

还是那句话：若数组**不包含 target** 时，最终 left 和 right 会分别指向首个大于、小于 target 的元素。

所以：上面的办法是类似不包含target，那我们可以直接**构造出一个数组中不存在target的情况**，用于查找左右边界：

- 查找最左一个 `target` ：可以转化为查找 `target - 0.5` ，并返回指针 left 。
- 查找最右一个 `target` ：可以转化为查找 `target + 0.5` ，并返回指针 right ，即left - 1。

注意以下两点：

- 给定数组不包含小数，这意味着我们无须关心如何处理相等的情况。
- 因为该方法引入了小数，所以需要将函数中的变量 `target` 改为浮点数类型。

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int leftBorder = getBorder(nums, target - 0.5);
        int rightBorder = getBorder(nums, target + 0.5) - 1;

        if(leftBorder == nums.length || nums[leftBorder] != target) {
            return new int[]{-1,-1};
        }
        if (rightBorder == -1 || nums[rightBorder] != target) {
            return new int[]{-1,-1};
        }
        return new int[]{leftBorder,rightBorder};
    }

    private int getBorder(int[] nums, double target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int middle = left + (right - left) / 2;
            if(nums[middle] < target) {
                left = middle + 1;
            } else if(nums[middle] > target) {
                right = middle - 1;
            }//不可能存在相等情况
        }
        return left;
    }
}
```

# 双指针法

适用数据结构：数组、链表、字符串

**我认为：双指针不一定就两个指针，有些情况下你可以多用一些指针**
比如题 [977.有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/) 就使用了三个指针

> 并且要观察题目**有没有要求原地修改**，没有要求原地修改是可以**新建数组**或**复制数组**的

两种双指针法：

1. 普通双指针法	slowIndex, fastIndex
2. 相向双指针法    leftIndex, rightIndex

双指针：一般是**移动**（移除、去重、移动、平方、反转、交换）

相关题目：
[27.移除元素](https://leetcode.cn/problems/remove-element/)
[26.删除排序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)
[283.移动零](https://leetcode.cn/problems/move-zeroes/)
[844.比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)
[977.有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)	使用了三指针，且新建了空数组

[206.反转链表](https://leetcode.cn/problems/reverse-linked-list/)
[24.两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)
[19.删除(移除)链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
[160.相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)
[142.环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

[15.三数之和](https://leetcode.cn/problems/3sum/)
[18.四数之和](https://leetcode.cn/problems/4sum/)

[344.反转字符串](https://leetcode.cn/problems/reverse-string/)
[541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)
[151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)



27.移除元素 举例：

```java
//双指针法
class Solution {
    public int removeElement(int[] nums, int val) {
        int slowIndex = 0;
        for(int fastIndex = 0; fastIndex < nums.length; fastIndex++) {
            if(nums[fastIndex] != val) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
}
```

```java
//相向双指针
class Solution {
    public int removeElement(int[] nums, int val) {
        int leftIndex = 0;
        int rightIndex = nums.length - 1;
        while(leftIndex <= rightIndex) {
            while(leftIndex <= rightIndex && nums[leftIndex] != val) {
                leftIndex++;
            }
            while(leftIndex <= rightIndex && nums[rightIndex] == val) {
                rightIndex--;
            }
            if(leftIndex < rightIndex) {
                nums[leftIndex++] = nums[rightIndex--];
            }
        }
        return leftIndex;
    }
}
```



# 滑动窗口

适用数据结构：数组、链表、字符串

滑动窗口可以看成双指针法的一种，只是**双指针法一般要移动元素**，而**滑动窗口一般是寻找子数组**

滑动窗口：一般是**寻找子数组、字串等**

相关题目：
[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)
[904.水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)
[76.最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)
[438.找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/) <=> 找到字符串中由另一个字符串的字符所组成的字串

[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)	即实现strStr()   可以用滑动窗口实现

> 滑动窗口很多时候需要用到**哈希表进行辅助存储**

209.长度最小的子数组 举例：

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        //滑动窗口法：其实也是双指针法的一种
        int slowIndex = 0;
        int sum = 0;
        int result = Integer.MAX_VALUE;
        for(int fastIndex = 0; fastIndex < nums.length; fastIndex++) {
            sum += nums[fastIndex];
            while(sum >= target) {
                result = Math.min(result, fastIndex - slowIndex + 1);
                sum -= nums[slowIndex++];
            }
        }
        return result == Integer.MAX_VALUE ? 0 : result;
    }
}
```

438.找到字符串中所有字母异位词 举例：

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int sLen = s.length(), pLen = p.length();

        if(sLen < pLen) {
            return new ArrayList<>();
        }

        List<Integer> ans = new ArrayList<>();
        //数组代替哈希表，也可以使用Map<Character, Integer>
        int [] sCount = new int[26];
        int [] pCount = new int[26];
        for(int i = 0; i < pLen; i++) {
            ++sCount[s.charAt(i) - 'a'];
            ++pCount[p.charAt(i) - 'a'];
        }

        //前pLen个字符相等，则第一个位置是0
        if(Arrays.equals(sCount, pCount)) {
            ans.add(0);
        }

        for(int i = 0; i < sLen - pLen; i++) {
            //构造一个长度为pLen的滑动窗口，看窗口内的字符是否和p的字符相等
            --sCount[s.charAt(i) - 'a'];
            ++sCount[s.charAt(i + pLen) - 'a'];

            if(Arrays.equals(sCount, pCount)) {
                ans.add(i + 1);
            }
        }
        return ans;
    }
}
```

# KMP前缀表算法

> 以下部分截取自 [代码随想录-实现strStr()](https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%80%9D%E8%B7%AF)

KMP的经典思想就是:**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。**

**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**。
**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。

长度为前1个字符的子串`a`，**最长相同前后缀**的长度为0
长度为前2个字符的子串`aa`，**最长相同前后缀**的长度为1
长度为前3个字符的子串`aab`，**最长相同前后缀**的长度为0
长度为前4个字符的子串`aaba`，**最长相同前后缀**的长度为1
长度为前5个字符的子串`aabaa`，**最长相同前后缀**的长度为2
长度为前6个字符的子串`aabaaf`，**最长相同前后缀**的长度为0

**前缀表：**
![KMP精讲2](image/算法.assets/KMP精讲2.gif)

**next数组：**
next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。
减一情况：
![KMP精讲4](image/算法.assets/KMP精讲4.gif)

- 不减一情况：判断时匹配当前j，不等时匹配next[j - 1]
- 减一情况：判断时匹配当前j + 1，不等时匹配next[j]

时间复杂度是O(n+m)，空间复杂度是O(m)



相关题目：
[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)	即实现strStr()
[459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)



28.找出字符串中第一个匹配项的下标 举例：

这里用KMP法，还可以使用滑动窗口法 和 利用java的substring()（思路最简单），这两种方法具体代码到题目提交记录中查看

```java
class Solution {

    public void getNext(int[] next, String needle) {
        int j = -1;
        //前缀表j-1法：next[i] = 此处前面的最长相同前后缀长度 - 1
        next[0] = j;

        for(int i = 1; i < needle.length(); i++) {
            while(j >= 0 && needle.charAt(i) != needle.charAt(j + 1)) {
                j = next[j];
            }
            if(needle.charAt(i) == needle.charAt(j + 1)) {
                j++;
            }
            next[i] = j;
        }
    }

    public int strStr(String haystack, String needle) {
        int[] next = new int[needle.length()];
        this.getNext(next, needle);
        int j = -1;
        for(int i = 0; i < haystack.length(); i++) {
            while(j >= 0 && haystack.charAt(i) != needle.charAt(j + 1)) {
                j = next[j];
            }
            if(haystack.charAt(i) == needle.charAt(j + 1)){
                j++;
            }
            if(j == needle.length() - 1) {
                return i - needle.length() + 1;
            }
        }
        return -1;
    }
}
```

```java
class Solution {

    public void getNext(int[] next, String needle) {
        int j = 0;
        //前缀表j不减1法：next[i] = 此处前面的最长相同前后缀长度，但是遇到不等时需要找到next[j-1]
        next[0] = j;

        for(int i = 1; i < needle.length(); i++) {
            while(j > 0 && needle.charAt(i) != needle.charAt(j)) {
                j = next[j - 1];
            }
            if(needle.charAt(i) == needle.charAt(j)) {
                j++;
            }
            next[i] = j;
        }
    }

    public int strStr(String haystack, String needle) {
        int[] next = new int[needle.length()];
        this.getNext(next, needle);
        int j = 0;
        for(int i = 0; i < haystack.length(); i++) {
            while(j > 0 && haystack.charAt(i) != needle.charAt(j)) {
                j = next[j - 1];
            }
            if(haystack.charAt(i) == needle.charAt(j)) {
                j++;
            }
            if(j == needle.length()) {
                return i - needle.length() + 1;
            }
        }
        return -1;
    }
}
```



459.重复的子字符串 举例：

是否由重复的子字符串构成

```java
//KMP
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        int len = s.length();
        int[] next = new int[len];

        //构造next数组
        int j = -1;
       	next[0] = j;
        for(int i = 1; i < len; i++) {
            while(j >= 0 && s.charAt(i) != s.charAt(j + 1)) {
                j = next[j];
            }
            if(s.charAt(i) == s.charAt(j + 1)){
                j++;
            }
            next[i] = j;
        }

        if(next[len - 1] != -1 && len % (len - (next[len - 1] + 1)) == 0) return true;

        return false;
        
        //法2
        String str = s + s;
        return str.substring(1,str.length() - 1).contains(s);
    }
}
```























